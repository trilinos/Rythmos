              INSTRUCTIONS FOR ADDING PYTHON WRAPPERS
                 TO YOUR EXISTING TRILINOS PACKAGE

                  Bill Spotz, wfspotz@sandia.gov

                          April 10, 2005

I have compiled a list of necessary steps to generate wrappers for
your Trilinos package to interface it with python.  The workhorse for
doing this is swig (Simple Wrapper Interface Generator).  It takes an
interface file (*.i -- which lists header files and contains other
directives) and generates a wrapper file (*_wrap.cpp) and a python
proxy file (*.py).  The C++ file must be compiled into a shared
object or dynamic library, depending on the platform.  There are two
portable ways to do this.  One, write a python script (called
setup.py by convention) that imports the distutils module and define
the package and extensions using distutils classes and functions.  Or
two, use libtool.  This New_Package package has been wrapped with the
first method.  See NOX/LOCA for an example of the second.

While the Trilinos project tries to impose as few restrictions on
packages as possible, there is great benefit in following a few
standards with regard to python wrappers.  The first standard is that
Trilinos packages should be imported into python using

     from PyTrilinos import YOUR_PACKAGE

syntax.  This will keep all the Trilinos python modules installed in
the same place and reduce clutter at the global namespace level.
This is achieved by using the "package=" option in the swig %module
directive when writing your interface file: 

     %module(package=PyTrilinos) YOUR_PACKAGE

and by including the PyTrilinos package name in the definitions in
the setup.py script.  See {new_package,epetra,epetraext}/python/src/
setup.py for examples.

The other standard is maintaining a common directory structure.  This
helps by (1) allowing test scripts for a package that depends on other
packages to find those modules easily, and (2) allowing automatic
documentation tools to search directories to find interface files and
keep current documentation on which header files of which packages
have been wrapped.  In the CVS repository, this directory structure is
currently

     YOUR_PACKAGE/python/            Subdirectories
     YOUR_PACKAGE/python/doc         Documentation
     YOUR_PACKAGE/python/example     Example scripts
     YOUR_PACKAGE/python/src*        Interface files, source files,
                                     setup.py and __init__.py scripts 
     YOUR_PACKAGE/python/src*/.deps  Dummy file, used to force
                                     creation of dependency directory
                                     in build tree
     YOUR_PACKAGE/python/test        Test scripts

A third benefit is that it will allow the test harness to search for
python scripts to run automatically.

The New_Package package has been wrapped to provide an example of how
it is done.  You will also need to become familiar with writing swig
interface files and setup.py scripts.  My hope is that there is
enough here to get you most of the way.

To add python wrappers to your existing Trilinos package, do the
following:

1. From new_package/config, copy the following files to
   YOUR_PACKAGE/config:

     ac_pkg_swig.m4
     ac_python_module.m4
     az_python.m4
     swig.am
     tac_python_enable.m4

2. Edit YOUR_PACKAGE/configure.ac.  Copy the following lines into
   YOUR_PACKAGE/configure.ac:

     # ------------------------------------------------------------------------
     # Enable optional python wrappers
     # ------------------------------------------------------------------------
     TAC_ENABLE_PYTHON

   The location you paste it is probably not crucial, but I have been
   putting it just before the "Specify other directories" section
   present in most of the Trilinos configure.ac files.  At the end of
   configure.ac, add the following files to the AC_CONFIG_FILES macro:

     python/Makefile
     python/src/Makefile
     python/src/__init__.py
     python/src/.deps/dummy
     python/test/Makefile
     python/example/Makefile

   (Note the python/src/.deps/dummy file.  Because the Makefile
   ultimately compiles the wrapper files by running "python setup.py
   build", the automake system does not recognize the compilation and
   does not automatically create dependency files.  Thus we force
   configure to create the .deps directory manually by creating a
   dummy file in it.)

3. Edit YOUR_PACKAGE/Makefile.am to contain the following:

     if BUILD_PYTHON
     PYTHON_SUBDIR=python
     endif

   and make sure the SUBDIRS definition includes $(PYTHON_SUBDIR).

4. Recursively copy the new_package/python directory to
   YOUR_PACKAGE/python.  Personally, I would delete the CVS
   directories and manually "cvs add" all the directories and files
   you want to put in the repository once things are working.

In YOUR_PACKAGE/python/src, do the following:

5. Edit Makefile.am.  Change the definition of SWIG_CXXFLAGS to be a
   complete list of needed "-I" include directories and "-D"
   definitions (and anything else) that swig will need to generate the
   wrappers.  Change the definition of INTERFACES to be a list of the
   swig interface files that should be wrapped.  (Note that a python
   module defines a namespace, so it is best to define a single
   interface file for each namespace in your package.)  You can
   probably delete the lines that involve SWAHILI.

6. Edit the __init__.py.in file.  Change the definition of the list
   "all" to include the names of all of the modules in your package.

7. Edit the setup.py script.  This file is hopefully documented
   sufficiently that you can read through it and change the variable
   values and definitions to what is needed for your package.  The
   important thing is to define the package properly and provide all
   of the correct source files, include directories, library
   directories, libraries, compiler arguments and linker arguments
   needed to build each extension.

8. Remove the SWIG interface file, python/src/New_Package.i, or change
   the name to python/src/YOUR_PACKAGE.i.  Create any additional
   interface files needed by your project.  Writing an interface file
   is relatively straight-forward, but beyond the scope of these
   instructions.  Use what is given as an example and consult the
   documentation at http://www.swig.org.

At this point, if you have kept the interface file simple, there
should be sufficient infrastructure in place to bootstrap at the
directory level, configure and attempt a make.  When you configure,
use "--enable-python[=path]" or "--with-python[=path]" to trigger
creation of the wrappers.  If swig is not in your path or you wish to
specify a different swig, use "--with-swig=path".  After debugging,
you can go on to the following steps:

9.  Edit the python/test/Makefile.am file.  Define TEST_SUITE to be a
    list of test scripts, omitting the ".py" extension.  For each test
    listed in TEST_SUITE, there should be a corresponding python
    script in the test directory, named with a ".py" extension.
    (Don't forget to keep the EXTRA_DIST macro up-to-date.)  The
    new_package test uses the python unittest facility, and is an
    excellent framework for quickly developing unit tests for your
    wrapped package.

10. If your tests require access to python wrappers from another
    package, the proper path needs to be added to python's search
    path.  This is done by editing python/test/setpath.py.  Use the
    logic for finding epetra's path in new_package's setpath.py as a
    guide.

11. The test scripts can be invoked by running "make check".  Debug
    if necessary.

12. Repeat steps 9--11 for the python/example subdirectory.  The
    Makefile defines EXAMPLE_SUITE instead of TEST_SUITE, but
    otherwise the procedure is the same.

Good luck!
